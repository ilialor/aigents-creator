import aiohttp
import json
from typing import Dict, List, Any
import redis
from uuid import uuid4

class LLMOrchestrator:
    def __init__(self):
        self.ollama_url = "http://aigents-storage-ollama-1:11434"
        self.practice_store_url = "http://aigents-storage-api-1:8000/practices"
        self.redis = redis.Redis(host='redis', port=6379, decode_responses=True)
        
    async def generate_practice(self, idea: Dict, similar_practices: List[Dict]) -> Dict:
        """
        Генерирует практику через несколько итераций с LLM
        """
        practice_id = str(uuid4())
        
        try:
            # Шаг 1: Генерация черновика MD
            print(f"Generating MD draft for {practice_id}")
            md_prompt = self._create_md_prompt(idea, similar_practices)
            md_draft = await self._call_llm(md_prompt)
            print(f"MD draft generated: {md_draft[:100]}...")
            
            # Шаг 2: Генерация JSON
            print(f"Generating JSON for {practice_id}")
            json_prompt = self._create_json_prompt(md_draft, similar_practices)
            practice_json_str = await self._call_llm(json_prompt)
            
            # Пытаемся найти и распарсить JSON в ответе
            json_start = practice_json_str.find('{')
            json_end = practice_json_str.rfind('}')
            
            if json_start >= 0 and json_end > json_start:
                json_str = practice_json_str[json_start:json_end + 1]
                json_str = ' '.join(line.strip() for line in json_str.splitlines())
                
                try:
                    practice_json = json.loads(json_str)
                    print(f"Successfully parsed JSON for {practice_id}")
                except json.JSONDecodeError as e:
                    print(f"Failed to parse JSON: {e}")
                    print(f"Raw JSON string: {json_str}")
                    raise Exception("Invalid JSON generated by LLM")
            else:
                print(f"No JSON found in response: {practice_json_str[:200]}...")
                raise Exception("No JSON found in LLM response")
            
            # Шаг 3: Уточнение различий
            if similar_practices:
                print(f"Refining differences for {practice_id}")
                diff_prompt = self._create_diff_prompt(practice_json, similar_practices)
                practice_json_str = await self._call_llm(diff_prompt)
                try:
                    practice_json = json.loads(practice_json_str)
                except json.JSONDecodeError as e:
                    print(f"Failed to parse refined JSON: {e}")
                    print(f"Raw refined JSON string: {practice_json_str}")
                    raise Exception("Invalid JSON generated by LLM")
            
            # Сохраняем в Practice Store
            print(f"Saving practice {practice_id}")
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.practice_store_url,
                    json=practice_json
                ) as response:
                    if response.status != 201:
                        error_text = await response.text()
                        print(f"Failed to save practice: {error_text}")
                        print(f"Practice JSON: {json.dumps(practice_json, indent=2)}")
                        raise Exception(f"Failed to save practice: {error_text}")
                    
            return practice_json
            
        except Exception as e:
            print(f"Error generating practice {practice_id}: {str(e)}")
            raise
    
    def _create_md_prompt(self, idea: Dict, similar_practices: List[Dict]) -> str:
        return f"""You are an expert system. Create a detailed practice description in markdown format.
        IMPORTANT: Use EXACTLY the provided idea and do not invent or change the core concept.
        
        Input Idea:
        Title: {idea['title']}
        Description: {idea['description']}
        Domain: {idea.get('domain', 'Not specified')}
        
        Similar practices to consider:
        {json.dumps(similar_practices, indent=2)}
        
        Create a markdown document that expands on the EXACT provided idea. Do not change the core concept.
        Include these sections:
        - Title (use exactly: "{idea['title']}")
        - Summary (based on the provided description)
        - Problem Statement
        - Solution
        - Implementation Steps
        - Benefits
        - Limitations
        - Requirements
        
        The practice should be about: "{idea['description']}"
        Domain context: {idea.get('domain', 'General')}
        """
    
    def _create_json_prompt(self, md_draft: str, similar_practices: List[Dict]) -> str:
        return f"""Convert this markdown practice description into a structured JSON format.
        IMPORTANT: Return ONLY the JSON object without any additional text or explanations.
        Do not add any text before or after the JSON.
        The response should start with '{{' and end with '}}'.
        Use short keys for dictionaries.
        
        Example of correct response:
        {{
            "title": "Example",
            "benefits": {{
                "benefit1": "Description of first benefit",
                "benefit2": "Description of second benefit"
            }}
        }}
        
        Example of incorrect response:
        Here is the JSON:
        {{
            "title": "Example",
            "benefits": {{
                "this is a very long key that describes the benefit": "Description"
            }}
        }}
        
        Markdown:
        {md_draft}
        
        Required JSON structure:
        {{
            "title": "string",
            "summary": "string",
            "problem": "string",
            "solution": "string",
            "implementation_steps": ["string"],
            "benefits": {{
                "key1": "value1",
                "key2": "value2"
            }},
            "limitations": {{
                "limit1": "description1",
                "limit2": "description2"
            }},
            "requirements": {{
                "req1": "description1",
                "req2": "description2"
            }},
            "domain": "string",
            "sub_domains": ["string"],
            "tags": ["string"]
        }}
        """
    
    def _create_diff_prompt(self, practice_json: Dict, similar_practices: List[Dict]) -> str:
        return f"""Review this practice against similar ones and clarify differences.
        
        New practice:
        {json.dumps(practice_json, indent=2)}
        
        Similar practices:
        {json.dumps(similar_practices, indent=2)}
        
        Update the JSON to highlight unique aspects in:
        - solution
        - benefits
        - limitations
        """
    
    async def _call_llm(self, prompt: str) -> Any:
        """
        Вызывает LLM через ollama
        """
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": "llama2",
                    "prompt": prompt,
                    "temperature": 0.7,
                    "max_tokens": 2048
                }
            ) as response:
                full_response = ""
                buffer = ""
                
                async for chunk in response.content.iter_chunked(1024):
                    buffer += chunk.decode()
                    lines = buffer.split('\n')
                    
                    for line in lines[:-1]:
                        if line.strip():
                            try:
                                data = json.loads(line)
                                if 'response' in data:
                                    full_response += data['response']
                            except json.JSONDecodeError:
                                continue
                    
                    buffer = lines[-1]
                
                if buffer.strip():
                    try:
                        data = json.loads(buffer)
                        if 'response' in data:
                            full_response += data['response']
                    except json.JSONDecodeError:
                        pass

                # Пытаемся найти и распарсить JSON
                try:
                    # Ищем начало и конец JSON
                    json_start = full_response.find('{')
                    json_end = full_response.rfind('}')
                    
                    if json_start >= 0 and json_end > json_start:
                        # Извлекаем JSON часть
                        json_str = full_response[json_start:json_end + 1]
                        
                        # Убираем переносы строк и лишние пробелы
                        json_str = ' '.join(line.strip() for line in json_str.splitlines())
                        
                        # Пробуем распарсить
                        try:
                            return json.loads(json_str)
                        except json.JSONDecodeError as e:
                            print(f"Failed to parse cleaned JSON: {e}")
                            print(f"Cleaned JSON string: {json_str}")
                    else:
                        print(f"No JSON found in response: {full_response[:200]}...")
                        
                    return full_response
                except Exception as e:
                    print(f"Error processing response: {e}")
                    return full_response 